// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribePositionRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionResponse {
    /// The next position
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Position>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeHomeRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HomeResponse {
    /// The next home position
    #[prost(message, optional, tag = "1")]
    pub home: ::core::option::Option<Position>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeInAirRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InAirResponse {
    /// The next 'in-air' state
    #[prost(bool, tag = "1")]
    pub is_in_air: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeLandedStateRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LandedStateResponse {
    /// The next 'landed' state
    #[prost(enumeration = "LandedState", tag = "1")]
    pub landed_state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeArmedRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArmedResponse {
    /// The next 'armed' state
    #[prost(bool, tag = "1")]
    pub is_armed: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeVtolStateRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VtolStateResponse {
    /// The next 'vtol' state
    #[prost(enumeration = "VtolState", tag = "1")]
    pub vtol_state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeAttitudeQuaternionRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttitudeQuaternionResponse {
    /// The next attitude (quaternion)
    #[prost(message, optional, tag = "1")]
    pub attitude_quaternion: ::core::option::Option<Quaternion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeAttitudeEulerRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttitudeEulerResponse {
    /// The next attitude (Euler)
    #[prost(message, optional, tag = "1")]
    pub attitude_euler: ::core::option::Option<EulerAngle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeAttitudeAngularVelocityBodyRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttitudeAngularVelocityBodyResponse {
    /// The next angular velocity (rad/s)
    #[prost(message, optional, tag = "1")]
    pub attitude_angular_velocity_body: ::core::option::Option<AngularVelocityBody>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCameraAttitudeQuaternionRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CameraAttitudeQuaternionResponse {
    /// The next camera attitude (quaternion)
    #[prost(message, optional, tag = "1")]
    pub attitude_quaternion: ::core::option::Option<Quaternion>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeCameraAttitudeEulerRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CameraAttitudeEulerResponse {
    /// The next camera attitude (Euler)
    #[prost(message, optional, tag = "1")]
    pub attitude_euler: ::core::option::Option<EulerAngle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeVelocityNedRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VelocityNedResponse {
    /// The next velocity (NED)
    #[prost(message, optional, tag = "1")]
    pub velocity_ned: ::core::option::Option<VelocityNed>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeGpsInfoRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpsInfoResponse {
    /// The next 'GPS info' state
    #[prost(message, optional, tag = "1")]
    pub gps_info: ::core::option::Option<GpsInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRawGpsRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawGpsResponse {
    /// The next 'Raw GPS' state. Warning: this is an advanced feature, use `Position` updates to get the location of the drone!
    #[prost(message, optional, tag = "1")]
    pub raw_gps: ::core::option::Option<RawGps>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeBatteryRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatteryResponse {
    /// The next 'battery' state
    #[prost(message, optional, tag = "1")]
    pub battery: ::core::option::Option<Battery>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeFlightModeRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlightModeResponse {
    /// The next flight mode
    #[prost(enumeration = "FlightMode", tag = "1")]
    pub flight_mode: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeHealthRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    /// The next 'health' state
    #[prost(message, optional, tag = "1")]
    pub health: ::core::option::Option<Health>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRcStatusRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcStatusResponse {
    /// The next RC status
    #[prost(message, optional, tag = "1")]
    pub rc_status: ::core::option::Option<RcStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeStatusTextRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusTextResponse {
    /// The next 'status text'
    #[prost(message, optional, tag = "1")]
    pub status_text: ::core::option::Option<StatusText>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeActuatorControlTargetRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActuatorControlTargetResponse {
    /// The next actuator control target
    #[prost(message, optional, tag = "1")]
    pub actuator_control_target: ::core::option::Option<ActuatorControlTarget>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeActuatorOutputStatusRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActuatorOutputStatusResponse {
    /// The next actuator output status
    #[prost(message, optional, tag = "1")]
    pub actuator_output_status: ::core::option::Option<ActuatorOutputStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeOdometryRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OdometryResponse {
    /// The next odometry status
    #[prost(message, optional, tag = "1")]
    pub odometry: ::core::option::Option<Odometry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribePositionVelocityNedRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionVelocityNedResponse {
    /// The next position and velocity status
    #[prost(message, optional, tag = "1")]
    pub position_velocity_ned: ::core::option::Option<PositionVelocityNed>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeGroundTruthRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundTruthResponse {
    /// Ground truth position information available in simulation
    #[prost(message, optional, tag = "1")]
    pub ground_truth: ::core::option::Option<GroundTruth>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeFixedwingMetricsRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixedwingMetricsResponse {
    /// The next fixedwing metrics
    #[prost(message, optional, tag = "1")]
    pub fixedwing_metrics: ::core::option::Option<FixedwingMetrics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeImuRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImuResponse {
    /// The next IMU status
    #[prost(message, optional, tag = "1")]
    pub imu: ::core::option::Option<Imu>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeScaledImuRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScaledImuResponse {
    /// The next scaled IMU status
    #[prost(message, optional, tag = "1")]
    pub imu: ::core::option::Option<Imu>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeRawImuRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawImuResponse {
    /// The next raw IMU status
    #[prost(message, optional, tag = "1")]
    pub imu: ::core::option::Option<Imu>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeHealthAllOkRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthAllOkResponse {
    /// The next 'health all ok' status
    #[prost(bool, tag = "1")]
    pub is_health_all_ok: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeUnixEpochTimeRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnixEpochTimeResponse {
    /// The next 'unix epoch time' status
    #[prost(uint64, tag = "1")]
    pub time_us: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeDistanceSensorRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistanceSensorResponse {
    /// The next Distance Sensor status
    #[prost(message, optional, tag = "1")]
    pub distance_sensor: ::core::option::Option<DistanceSensor>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeScaledPressureRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScaledPressureResponse {
    /// The next Scaled Pressure status
    #[prost(message, optional, tag = "1")]
    pub scaled_pressure: ::core::option::Option<ScaledPressure>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeHeadingRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeadingResponse {
    /// The next heading (yaw) in degrees
    #[prost(message, optional, tag = "1")]
    pub heading_deg: ::core::option::Option<Heading>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRatePositionRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRatePositionResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateHomeRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateHomeResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateInAirRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateInAirResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateLandedStateRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateLandedStateResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateVtolStateRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateVtolStateResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateAttitudeRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateAttitudeResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateAttitudeAngularVelocityBodyRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateAttitudeAngularVelocityBodyResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateCameraAttitudeQuaternionRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateCameraAttitudeQuaternionResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateCameraAttitudeRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateCameraAttitudeResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateVelocityNedRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateVelocityNedResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateGpsInfoRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateGpsInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateRawGpsRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateBatteryRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateBatteryResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateRcStatusRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateRcStatusResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateActuatorControlTargetRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateActuatorControlTargetResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateActuatorOutputStatusRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateActuatorOutputStatusResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateOdometryRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateOdometryResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRatePositionVelocityNedRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRatePositionVelocityNedResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateGroundTruthRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateGroundTruthResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateFixedwingMetricsRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateFixedwingMetricsResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateImuRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateImuResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateScaledImuRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateScaledImuResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateRawImuRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateRawImuResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateUnixEpochTimeRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateUnixEpochTimeResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateDistanceSensorRequest {
    /// The requested rate (in Hertz)
    #[prost(double, tag = "1")]
    pub rate_hz: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetRateDistanceSensorResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGpsGlobalOriginRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGpsGlobalOriginResponse {
    #[prost(message, optional, tag = "1")]
    pub telemetry_result: ::core::option::Option<TelemetryResult>,
    #[prost(message, optional, tag = "2")]
    pub gps_global_origin: ::core::option::Option<GpsGlobalOrigin>,
}
/// Position type in global coordinates.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    /// Latitude in degrees (range: -90 to +90)
    #[prost(double, tag = "1")]
    pub latitude_deg: f64,
    /// Longitude in degrees (range: -180 to +180)
    #[prost(double, tag = "2")]
    pub longitude_deg: f64,
    /// Altitude AMSL (above mean sea level) in metres
    #[prost(float, tag = "3")]
    pub absolute_altitude_m: f32,
    /// Altitude relative to takeoff altitude in metres
    #[prost(float, tag = "4")]
    pub relative_altitude_m: f32,
}
/// Heading type used for global position
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Heading {
    /// Heading in degrees (range: 0 to +360)
    #[prost(double, tag = "1")]
    pub heading_deg: f64,
}
///
/// Quaternion type.
///
/// All rotations and axis systems follow the right-hand rule.
/// The Hamilton quaternion product definition is used.
/// A zero-rotation quaternion is represented by (1,0,0,0).
/// The quaternion could also be written as w + xi + yj + zk.
///
/// For more info see: <https://en.wikipedia.org/wiki/Quaternion>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quaternion {
    /// Quaternion entry 0, also denoted as a
    #[prost(float, tag = "1")]
    pub w: f32,
    /// Quaternion entry 1, also denoted as b
    #[prost(float, tag = "2")]
    pub x: f32,
    /// Quaternion entry 2, also denoted as c
    #[prost(float, tag = "3")]
    pub y: f32,
    /// Quaternion entry 3, also denoted as d
    #[prost(float, tag = "4")]
    pub z: f32,
    /// Timestamp in microseconds
    #[prost(uint64, tag = "5")]
    pub timestamp_us: u64,
}
///
/// Euler angle type.
///
/// All rotations and axis systems follow the right-hand rule.
/// The Euler angles follow the convention of a 3-2-1 intrinsic Tait-Bryan rotation sequence.
///
/// For more info see <https://en.wikipedia.org/wiki/Euler_angles>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EulerAngle {
    /// Roll angle in degrees, positive is banking to the right
    #[prost(float, tag = "1")]
    pub roll_deg: f32,
    /// Pitch angle in degrees, positive is pitching nose up
    #[prost(float, tag = "2")]
    pub pitch_deg: f32,
    /// Yaw angle in degrees, positive is clock-wise seen from above
    #[prost(float, tag = "3")]
    pub yaw_deg: f32,
    /// Timestamp in microseconds
    #[prost(uint64, tag = "4")]
    pub timestamp_us: u64,
}
/// Angular velocity type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AngularVelocityBody {
    /// Roll angular velocity
    #[prost(float, tag = "1")]
    pub roll_rad_s: f32,
    /// Pitch angular velocity
    #[prost(float, tag = "2")]
    pub pitch_rad_s: f32,
    /// Yaw angular velocity
    #[prost(float, tag = "3")]
    pub yaw_rad_s: f32,
}
/// GPS information type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpsInfo {
    /// Number of visible satellites in use
    #[prost(int32, tag = "1")]
    pub num_satellites: i32,
    /// Fix type
    #[prost(enumeration = "FixType", tag = "2")]
    pub fix_type: i32,
}
///
/// Raw GPS information type.
///
/// Warning: this is an advanced type! If you want the location of the drone, use
/// the position instead. This message exposes the raw values of the GNSS sensor.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawGps {
    /// Timestamp in microseconds (UNIX Epoch time or time since system boot, to be inferred)
    #[prost(uint64, tag = "1")]
    pub timestamp_us: u64,
    /// Latitude in degrees (WGS84, EGM96 ellipsoid)
    #[prost(double, tag = "2")]
    pub latitude_deg: f64,
    /// Longitude in degrees (WGS84, EGM96 ellipsoid)
    #[prost(double, tag = "3")]
    pub longitude_deg: f64,
    /// Altitude AMSL (above mean sea level) in metres
    #[prost(float, tag = "4")]
    pub absolute_altitude_m: f32,
    /// GPS HDOP horizontal dilution of position (unitless). If unknown, set to NaN
    #[prost(float, tag = "5")]
    pub hdop: f32,
    /// GPS VDOP vertical dilution of position (unitless). If unknown, set to NaN
    #[prost(float, tag = "6")]
    pub vdop: f32,
    /// Ground velocity in metres per second
    #[prost(float, tag = "7")]
    pub velocity_m_s: f32,
    /// Course over ground (NOT heading, but direction of movement) in degrees. If unknown, set to NaN
    #[prost(float, tag = "8")]
    pub cog_deg: f32,
    /// Altitude in metres (above WGS84, EGM96 ellipsoid)
    #[prost(float, tag = "9")]
    pub altitude_ellipsoid_m: f32,
    /// Position uncertainty in metres
    #[prost(float, tag = "10")]
    pub horizontal_uncertainty_m: f32,
    /// Altitude uncertainty in metres
    #[prost(float, tag = "11")]
    pub vertical_uncertainty_m: f32,
    /// Velocity uncertainty in metres per second
    #[prost(float, tag = "12")]
    pub velocity_uncertainty_m_s: f32,
    /// Heading uncertainty in degrees
    #[prost(float, tag = "13")]
    pub heading_uncertainty_deg: f32,
    /// Yaw in earth frame from north.
    #[prost(float, tag = "14")]
    pub yaw_deg: f32,
}
/// Battery type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Battery {
    /// Battery ID, for systems with multiple batteries
    #[prost(uint32, tag = "3")]
    pub id: u32,
    /// Voltage in volts
    #[prost(float, tag = "1")]
    pub voltage_v: f32,
    /// Estimated battery remaining (range: 0.0 to 1.0)
    #[prost(float, tag = "2")]
    pub remaining_percent: f32,
}
/// Health type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Health {
    /// True if the gyrometer is calibrated
    #[prost(bool, tag = "1")]
    pub is_gyrometer_calibration_ok: bool,
    /// True if the accelerometer is calibrated
    #[prost(bool, tag = "2")]
    pub is_accelerometer_calibration_ok: bool,
    /// True if the magnetometer is calibrated
    #[prost(bool, tag = "3")]
    pub is_magnetometer_calibration_ok: bool,
    /// True if the local position estimate is good enough to fly in 'position control' mode
    #[prost(bool, tag = "5")]
    pub is_local_position_ok: bool,
    /// True if the global position estimate is good enough to fly in 'position control' mode
    #[prost(bool, tag = "6")]
    pub is_global_position_ok: bool,
    /// True if the home position has been initialized properly
    #[prost(bool, tag = "7")]
    pub is_home_position_ok: bool,
    /// True if system can be armed
    #[prost(bool, tag = "8")]
    pub is_armable: bool,
}
/// Remote control status type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RcStatus {
    /// True if an RC signal has been available once
    #[prost(bool, tag = "1")]
    pub was_available_once: bool,
    /// True if the RC signal is available now
    #[prost(bool, tag = "2")]
    pub is_available: bool,
    /// Signal strength (range: 0 to 100, NaN if unknown)
    #[prost(float, tag = "3")]
    pub signal_strength_percent: f32,
}
/// StatusText information type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatusText {
    /// Message type
    #[prost(enumeration = "StatusTextType", tag = "1")]
    pub r#type: i32,
    /// MAVLink status message
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
}
/// Actuator control target type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActuatorControlTarget {
    /// An actuator control group is e.g. 'attitude' for the core flight controls, or 'gimbal' for a payload.
    #[prost(int32, tag = "1")]
    pub group: i32,
    /// Controls normed from -1 to 1, where 0 is neutral position.
    #[prost(float, repeated, tag = "2")]
    pub controls: ::prost::alloc::vec::Vec<f32>,
}
/// Actuator output status type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActuatorOutputStatus {
    /// Active outputs
    #[prost(uint32, tag = "1")]
    pub active: u32,
    /// Servo/motor output values
    #[prost(float, repeated, tag = "2")]
    pub actuator: ::prost::alloc::vec::Vec<f32>,
}
///
/// Covariance type.
///
/// Row-major representation of a 6x6 cross-covariance matrix
/// upper right triangle.
/// Set first to NaN if unknown.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Covariance {
    /// Representation of a covariance matrix.
    #[prost(float, repeated, tag = "1")]
    pub covariance_matrix: ::prost::alloc::vec::Vec<f32>,
}
/// Velocity type, represented in the Body (X Y Z) frame and in metres/second.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VelocityBody {
    /// Velocity in X in metres/second
    #[prost(float, tag = "1")]
    pub x_m_s: f32,
    /// Velocity in Y in metres/second
    #[prost(float, tag = "2")]
    pub y_m_s: f32,
    /// Velocity in Z in metres/second
    #[prost(float, tag = "3")]
    pub z_m_s: f32,
}
/// Position type, represented in the Body (X Y Z) frame
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionBody {
    /// X Position in metres.
    #[prost(float, tag = "1")]
    pub x_m: f32,
    /// Y Position in metres.
    #[prost(float, tag = "2")]
    pub y_m: f32,
    /// Z Position in metres.
    #[prost(float, tag = "3")]
    pub z_m: f32,
}
/// Odometry message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Odometry {
    /// Timestamp (0 to use Backend timestamp).
    #[prost(uint64, tag = "1")]
    pub time_usec: u64,
    /// Coordinate frame of reference for the pose data.
    #[prost(enumeration = "odometry::MavFrame", tag = "2")]
    pub frame_id: i32,
    /// Coordinate frame of reference for the velocity in free space (twist) data.
    #[prost(enumeration = "odometry::MavFrame", tag = "3")]
    pub child_frame_id: i32,
    /// Position.
    #[prost(message, optional, tag = "4")]
    pub position_body: ::core::option::Option<PositionBody>,
    /// Quaternion components, w, x, y, z (1 0 0 0 is the null-rotation).
    #[prost(message, optional, tag = "5")]
    pub q: ::core::option::Option<Quaternion>,
    /// Linear velocity (m/s).
    #[prost(message, optional, tag = "6")]
    pub velocity_body: ::core::option::Option<VelocityBody>,
    /// Angular velocity (rad/s).
    #[prost(message, optional, tag = "7")]
    pub angular_velocity_body: ::core::option::Option<AngularVelocityBody>,
    /// Pose cross-covariance matrix.
    #[prost(message, optional, tag = "8")]
    pub pose_covariance: ::core::option::Option<Covariance>,
    /// Velocity cross-covariance matrix.
    #[prost(message, optional, tag = "9")]
    pub velocity_covariance: ::core::option::Option<Covariance>,
}
/// Nested message and enum types in `Odometry`.
pub mod odometry {
    /// Mavlink frame id
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MavFrame {
        /// Frame is undefined.
        Undef = 0,
        /// Setpoint in body NED frame. This makes sense if all position control is externalized - e.g. useful to command 2 m/s^2 acceleration to the right.
        BodyNed = 8,
        /// Odometry local coordinate frame of data given by a vision estimation system, Z-down (x: north, y: east, z: down).
        VisionNed = 16,
        /// Odometry local coordinate frame of data given by an estimator running onboard the vehicle, Z-down (x: north, y: east, z: down).
        EstimNed = 18,
    }
    impl MavFrame {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MavFrame::Undef => "MAV_FRAME_UNDEF",
                MavFrame::BodyNed => "MAV_FRAME_BODY_NED",
                MavFrame::VisionNed => "MAV_FRAME_VISION_NED",
                MavFrame::EstimNed => "MAV_FRAME_ESTIM_NED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MAV_FRAME_UNDEF" => Some(Self::Undef),
                "MAV_FRAME_BODY_NED" => Some(Self::BodyNed),
                "MAV_FRAME_VISION_NED" => Some(Self::VisionNed),
                "MAV_FRAME_ESTIM_NED" => Some(Self::EstimNed),
                _ => None,
            }
        }
    }
}
/// DistanceSensor message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistanceSensor {
    /// Minimum distance the sensor can measure, NaN if unknown.
    #[prost(float, tag = "1")]
    pub minimum_distance_m: f32,
    /// Maximum distance the sensor can measure, NaN if unknown.
    #[prost(float, tag = "2")]
    pub maximum_distance_m: f32,
    /// Current distance reading, NaN if unknown.
    #[prost(float, tag = "3")]
    pub current_distance_m: f32,
}
/// Scaled Pressure message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScaledPressure {
    /// Timestamp (time since system boot)
    #[prost(uint64, tag = "1")]
    pub timestamp_us: u64,
    /// Absolute pressure in hPa
    #[prost(float, tag = "2")]
    pub absolute_pressure_hpa: f32,
    /// Differential pressure 1 in hPa
    #[prost(float, tag = "3")]
    pub differential_pressure_hpa: f32,
    /// Absolute pressure temperature (in celsius)
    #[prost(float, tag = "4")]
    pub temperature_deg: f32,
    /// Differential pressure temperature (in celsius, 0 if not available)
    #[prost(float, tag = "5")]
    pub differential_pressure_temperature_deg: f32,
}
/// PositionNed message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionNed {
    /// Position along north direction in metres
    #[prost(float, tag = "1")]
    pub north_m: f32,
    /// Position along east direction in metres
    #[prost(float, tag = "2")]
    pub east_m: f32,
    /// Position along down direction in metres
    #[prost(float, tag = "3")]
    pub down_m: f32,
}
/// VelocityNed message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VelocityNed {
    /// Velocity along north direction in metres per second
    #[prost(float, tag = "1")]
    pub north_m_s: f32,
    /// Velocity along east direction in metres per second
    #[prost(float, tag = "2")]
    pub east_m_s: f32,
    /// Velocity along down direction in metres per second
    #[prost(float, tag = "3")]
    pub down_m_s: f32,
}
/// PositionVelocityNed message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionVelocityNed {
    /// Position (NED)
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<PositionNed>,
    /// Velocity (NED)
    #[prost(message, optional, tag = "2")]
    pub velocity: ::core::option::Option<VelocityNed>,
}
/// GroundTruth message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundTruth {
    /// Latitude in degrees (range: -90 to +90)
    #[prost(double, tag = "1")]
    pub latitude_deg: f64,
    /// Longitude in degrees (range: -180 to 180)
    #[prost(double, tag = "2")]
    pub longitude_deg: f64,
    /// Altitude AMSL (above mean sea level) in metres
    #[prost(float, tag = "3")]
    pub absolute_altitude_m: f32,
}
/// FixedwingMetrics message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixedwingMetrics {
    /// Current indicated airspeed (IAS) in metres per second
    #[prost(float, tag = "1")]
    pub airspeed_m_s: f32,
    /// Current throttle setting (0 to 100)
    #[prost(float, tag = "2")]
    pub throttle_percentage: f32,
    /// Current climb rate in metres per second
    #[prost(float, tag = "3")]
    pub climb_rate_m_s: f32,
}
/// AccelerationFrd message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccelerationFrd {
    /// Acceleration in forward direction in metres per second^2
    #[prost(float, tag = "1")]
    pub forward_m_s2: f32,
    /// Acceleration in right direction in metres per second^2
    #[prost(float, tag = "2")]
    pub right_m_s2: f32,
    /// Acceleration in down direction in metres per second^2
    #[prost(float, tag = "3")]
    pub down_m_s2: f32,
}
/// AngularVelocityFrd message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AngularVelocityFrd {
    /// Angular velocity in forward direction in radians per second
    #[prost(float, tag = "1")]
    pub forward_rad_s: f32,
    /// Angular velocity in right direction in radians per second
    #[prost(float, tag = "2")]
    pub right_rad_s: f32,
    /// Angular velocity in Down direction in radians per second
    #[prost(float, tag = "3")]
    pub down_rad_s: f32,
}
/// MagneticFieldFrd message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagneticFieldFrd {
    /// Magnetic field in forward direction measured in Gauss
    #[prost(float, tag = "1")]
    pub forward_gauss: f32,
    /// Magnetic field in East direction measured in Gauss
    #[prost(float, tag = "2")]
    pub right_gauss: f32,
    /// Magnetic field in Down direction measured in Gauss
    #[prost(float, tag = "3")]
    pub down_gauss: f32,
}
/// Imu message type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Imu {
    /// Acceleration
    #[prost(message, optional, tag = "1")]
    pub acceleration_frd: ::core::option::Option<AccelerationFrd>,
    /// Angular velocity
    #[prost(message, optional, tag = "2")]
    pub angular_velocity_frd: ::core::option::Option<AngularVelocityFrd>,
    /// Magnetic field
    #[prost(message, optional, tag = "3")]
    pub magnetic_field_frd: ::core::option::Option<MagneticFieldFrd>,
    /// Temperature
    #[prost(float, tag = "4")]
    pub temperature_degc: f32,
    /// Timestamp in microseconds
    #[prost(uint64, tag = "5")]
    pub timestamp_us: u64,
}
/// Gps global origin type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpsGlobalOrigin {
    /// Latitude of the origin
    #[prost(double, tag = "1")]
    pub latitude_deg: f64,
    /// Longitude of the origin
    #[prost(double, tag = "2")]
    pub longitude_deg: f64,
    /// Altitude AMSL (above mean sea level) in metres
    #[prost(float, tag = "3")]
    pub altitude_m: f32,
}
/// Result type.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TelemetryResult {
    /// Result enum value
    #[prost(enumeration = "telemetry_result::Result", tag = "1")]
    pub result: i32,
    /// Human-readable English string describing the result
    #[prost(string, tag = "2")]
    pub result_str: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TelemetryResult`.
pub mod telemetry_result {
    /// Possible results returned for telemetry requests.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        /// Unknown result
        Unknown = 0,
        /// Success: the telemetry command was accepted by the vehicle
        Success = 1,
        /// No system connected
        NoSystem = 2,
        /// Connection error
        ConnectionError = 3,
        /// Vehicle is busy
        Busy = 4,
        /// Command refused by vehicle
        CommandDenied = 5,
        /// Request timed out
        Timeout = 6,
        /// Request not supported
        Unsupported = 7,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::Unknown => "RESULT_UNKNOWN",
                Result::Success => "RESULT_SUCCESS",
                Result::NoSystem => "RESULT_NO_SYSTEM",
                Result::ConnectionError => "RESULT_CONNECTION_ERROR",
                Result::Busy => "RESULT_BUSY",
                Result::CommandDenied => "RESULT_COMMAND_DENIED",
                Result::Timeout => "RESULT_TIMEOUT",
                Result::Unsupported => "RESULT_UNSUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNKNOWN" => Some(Self::Unknown),
                "RESULT_SUCCESS" => Some(Self::Success),
                "RESULT_NO_SYSTEM" => Some(Self::NoSystem),
                "RESULT_CONNECTION_ERROR" => Some(Self::ConnectionError),
                "RESULT_BUSY" => Some(Self::Busy),
                "RESULT_COMMAND_DENIED" => Some(Self::CommandDenied),
                "RESULT_TIMEOUT" => Some(Self::Timeout),
                "RESULT_UNSUPPORTED" => Some(Self::Unsupported),
                _ => None,
            }
        }
    }
}
/// GPS fix type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FixType {
    /// No GPS connected
    NoGps = 0,
    /// No position information, GPS is connected
    NoFix = 1,
    /// 2D position
    Fix2d = 2,
    /// 3D position
    Fix3d = 3,
    /// DGPS/SBAS aided 3D position
    FixDgps = 4,
    /// RTK float, 3D position
    RtkFloat = 5,
    /// RTK Fixed, 3D position
    RtkFixed = 6,
}
impl FixType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FixType::NoGps => "FIX_TYPE_NO_GPS",
            FixType::NoFix => "FIX_TYPE_NO_FIX",
            FixType::Fix2d => "FIX_TYPE_FIX_2D",
            FixType::Fix3d => "FIX_TYPE_FIX_3D",
            FixType::FixDgps => "FIX_TYPE_FIX_DGPS",
            FixType::RtkFloat => "FIX_TYPE_RTK_FLOAT",
            FixType::RtkFixed => "FIX_TYPE_RTK_FIXED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIX_TYPE_NO_GPS" => Some(Self::NoGps),
            "FIX_TYPE_NO_FIX" => Some(Self::NoFix),
            "FIX_TYPE_FIX_2D" => Some(Self::Fix2d),
            "FIX_TYPE_FIX_3D" => Some(Self::Fix3d),
            "FIX_TYPE_FIX_DGPS" => Some(Self::FixDgps),
            "FIX_TYPE_RTK_FLOAT" => Some(Self::RtkFloat),
            "FIX_TYPE_RTK_FIXED" => Some(Self::RtkFixed),
            _ => None,
        }
    }
}
///
/// Flight modes.
///
/// For more information about flight modes, check out
/// <https://docs.px4.io/master/en/config/flight_mode.html.>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FlightMode {
    /// Mode not known
    Unknown = 0,
    /// Armed and ready to take off
    Ready = 1,
    /// Taking off
    Takeoff = 2,
    /// Holding (hovering in place (or circling for fixed-wing vehicles)
    Hold = 3,
    /// In mission
    Mission = 4,
    /// Returning to launch position (then landing)
    ReturnToLaunch = 5,
    /// Landing
    Land = 6,
    /// In 'offboard' mode
    Offboard = 7,
    /// In 'follow-me' mode
    FollowMe = 8,
    /// In 'Manual' mode
    Manual = 9,
    /// In 'Altitude Control' mode
    Altctl = 10,
    /// In 'Position Control' mode
    Posctl = 11,
    /// In 'Acro' mode
    Acro = 12,
    /// In 'Stabilize' mode
    Stabilized = 13,
    /// In 'Rattitude' mode
    Rattitude = 14,
}
impl FlightMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            FlightMode::Unknown => "FLIGHT_MODE_UNKNOWN",
            FlightMode::Ready => "FLIGHT_MODE_READY",
            FlightMode::Takeoff => "FLIGHT_MODE_TAKEOFF",
            FlightMode::Hold => "FLIGHT_MODE_HOLD",
            FlightMode::Mission => "FLIGHT_MODE_MISSION",
            FlightMode::ReturnToLaunch => "FLIGHT_MODE_RETURN_TO_LAUNCH",
            FlightMode::Land => "FLIGHT_MODE_LAND",
            FlightMode::Offboard => "FLIGHT_MODE_OFFBOARD",
            FlightMode::FollowMe => "FLIGHT_MODE_FOLLOW_ME",
            FlightMode::Manual => "FLIGHT_MODE_MANUAL",
            FlightMode::Altctl => "FLIGHT_MODE_ALTCTL",
            FlightMode::Posctl => "FLIGHT_MODE_POSCTL",
            FlightMode::Acro => "FLIGHT_MODE_ACRO",
            FlightMode::Stabilized => "FLIGHT_MODE_STABILIZED",
            FlightMode::Rattitude => "FLIGHT_MODE_RATTITUDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FLIGHT_MODE_UNKNOWN" => Some(Self::Unknown),
            "FLIGHT_MODE_READY" => Some(Self::Ready),
            "FLIGHT_MODE_TAKEOFF" => Some(Self::Takeoff),
            "FLIGHT_MODE_HOLD" => Some(Self::Hold),
            "FLIGHT_MODE_MISSION" => Some(Self::Mission),
            "FLIGHT_MODE_RETURN_TO_LAUNCH" => Some(Self::ReturnToLaunch),
            "FLIGHT_MODE_LAND" => Some(Self::Land),
            "FLIGHT_MODE_OFFBOARD" => Some(Self::Offboard),
            "FLIGHT_MODE_FOLLOW_ME" => Some(Self::FollowMe),
            "FLIGHT_MODE_MANUAL" => Some(Self::Manual),
            "FLIGHT_MODE_ALTCTL" => Some(Self::Altctl),
            "FLIGHT_MODE_POSCTL" => Some(Self::Posctl),
            "FLIGHT_MODE_ACRO" => Some(Self::Acro),
            "FLIGHT_MODE_STABILIZED" => Some(Self::Stabilized),
            "FLIGHT_MODE_RATTITUDE" => Some(Self::Rattitude),
            _ => None,
        }
    }
}
/// Status types.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StatusTextType {
    /// Debug
    Debug = 0,
    /// Information
    Info = 1,
    /// Notice
    Notice = 2,
    /// Warning
    Warning = 3,
    /// Error
    Error = 4,
    /// Critical
    Critical = 5,
    /// Alert
    Alert = 6,
    /// Emergency
    Emergency = 7,
}
impl StatusTextType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StatusTextType::Debug => "STATUS_TEXT_TYPE_DEBUG",
            StatusTextType::Info => "STATUS_TEXT_TYPE_INFO",
            StatusTextType::Notice => "STATUS_TEXT_TYPE_NOTICE",
            StatusTextType::Warning => "STATUS_TEXT_TYPE_WARNING",
            StatusTextType::Error => "STATUS_TEXT_TYPE_ERROR",
            StatusTextType::Critical => "STATUS_TEXT_TYPE_CRITICAL",
            StatusTextType::Alert => "STATUS_TEXT_TYPE_ALERT",
            StatusTextType::Emergency => "STATUS_TEXT_TYPE_EMERGENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATUS_TEXT_TYPE_DEBUG" => Some(Self::Debug),
            "STATUS_TEXT_TYPE_INFO" => Some(Self::Info),
            "STATUS_TEXT_TYPE_NOTICE" => Some(Self::Notice),
            "STATUS_TEXT_TYPE_WARNING" => Some(Self::Warning),
            "STATUS_TEXT_TYPE_ERROR" => Some(Self::Error),
            "STATUS_TEXT_TYPE_CRITICAL" => Some(Self::Critical),
            "STATUS_TEXT_TYPE_ALERT" => Some(Self::Alert),
            "STATUS_TEXT_TYPE_EMERGENCY" => Some(Self::Emergency),
            _ => None,
        }
    }
}
/// Landed State enumeration.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LandedState {
    /// Landed state is unknown
    Unknown = 0,
    /// The vehicle is on the ground
    OnGround = 1,
    /// The vehicle is in the air
    InAir = 2,
    /// The vehicle is taking off
    TakingOff = 3,
    /// The vehicle is landing
    Landing = 4,
}
impl LandedState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LandedState::Unknown => "LANDED_STATE_UNKNOWN",
            LandedState::OnGround => "LANDED_STATE_ON_GROUND",
            LandedState::InAir => "LANDED_STATE_IN_AIR",
            LandedState::TakingOff => "LANDED_STATE_TAKING_OFF",
            LandedState::Landing => "LANDED_STATE_LANDING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LANDED_STATE_UNKNOWN" => Some(Self::Unknown),
            "LANDED_STATE_ON_GROUND" => Some(Self::OnGround),
            "LANDED_STATE_IN_AIR" => Some(Self::InAir),
            "LANDED_STATE_TAKING_OFF" => Some(Self::TakingOff),
            "LANDED_STATE_LANDING" => Some(Self::Landing),
            _ => None,
        }
    }
}
/// VTOL State enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VtolState {
    /// MAV is not configured as VTOL
    Undefined = 0,
    /// VTOL is in transition from multicopter to fixed-wing
    TransitionToFw = 1,
    /// VTOL is in transition from fixed-wing to multicopter
    TransitionToMc = 2,
    /// VTOL is in multicopter state
    Mc = 3,
    /// VTOL is in fixed-wing state
    Fw = 4,
}
impl VtolState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VtolState::Undefined => "VTOL_STATE_UNDEFINED",
            VtolState::TransitionToFw => "VTOL_STATE_TRANSITION_TO_FW",
            VtolState::TransitionToMc => "VTOL_STATE_TRANSITION_TO_MC",
            VtolState::Mc => "VTOL_STATE_MC",
            VtolState::Fw => "VTOL_STATE_FW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VTOL_STATE_UNDEFINED" => Some(Self::Undefined),
            "VTOL_STATE_TRANSITION_TO_FW" => Some(Self::TransitionToFw),
            "VTOL_STATE_TRANSITION_TO_MC" => Some(Self::TransitionToMc),
            "VTOL_STATE_MC" => Some(Self::Mc),
            "VTOL_STATE_FW" => Some(Self::Fw),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod telemetry_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    ///
    /// Allow users to get vehicle telemetry and state information
    /// (e.g. battery, GPS, RC connection, flight mode etc.) and set telemetry update rates.
    #[derive(Debug, Clone)]
    pub struct TelemetryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TelemetryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TelemetryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TelemetryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TelemetryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to 'position' updates.
        pub async fn subscribe_position(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribePositionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PositionResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribePosition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribePosition",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'home position' updates.
        pub async fn subscribe_home(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeHomeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HomeResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeHome",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeHome",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to in-air updates.
        pub async fn subscribe_in_air(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeInAirRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::InAirResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeInAir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeInAir",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to landed state updates
        pub async fn subscribe_landed_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeLandedStateRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::LandedStateResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeLandedState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeLandedState",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to armed updates.
        pub async fn subscribe_armed(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeArmedRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ArmedResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeArmed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeArmed",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// subscribe to vtol state Updates
        pub async fn subscribe_vtol_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeVtolStateRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::VtolStateResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeVtolState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeVtolState",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'attitude' updates (quaternion).
        pub async fn subscribe_attitude_quaternion(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeAttitudeQuaternionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AttitudeQuaternionResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeAttitudeQuaternion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeAttitudeQuaternion",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'attitude' updates (Euler).
        pub async fn subscribe_attitude_euler(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeAttitudeEulerRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AttitudeEulerResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeAttitudeEuler",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeAttitudeEuler",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'attitude' updates (angular velocity)
        pub async fn subscribe_attitude_angular_velocity_body(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SubscribeAttitudeAngularVelocityBodyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::AttitudeAngularVelocityBodyResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeAttitudeAngularVelocityBody",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeAttitudeAngularVelocityBody",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'camera attitude' updates (quaternion).
        pub async fn subscribe_camera_attitude_quaternion(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SubscribeCameraAttitudeQuaternionRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::CameraAttitudeQuaternionResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeCameraAttitudeQuaternion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeCameraAttitudeQuaternion",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'camera attitude' updates (Euler).
        pub async fn subscribe_camera_attitude_euler(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeCameraAttitudeEulerRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CameraAttitudeEulerResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeCameraAttitudeEuler",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeCameraAttitudeEuler",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'ground speed' updates (NED).
        pub async fn subscribe_velocity_ned(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeVelocityNedRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::VelocityNedResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeVelocityNed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeVelocityNed",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'GPS info' updates.
        pub async fn subscribe_gps_info(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeGpsInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GpsInfoResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeGpsInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeGpsInfo",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'Raw GPS' updates.
        pub async fn subscribe_raw_gps(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeRawGpsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RawGpsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeRawGps",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeRawGps",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'battery' updates.
        pub async fn subscribe_battery(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeBatteryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BatteryResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeBattery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeBattery",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'flight mode' updates.
        pub async fn subscribe_flight_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeFlightModeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FlightModeResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeFlightMode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeFlightMode",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'health' updates.
        pub async fn subscribe_health(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeHealthRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HealthResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeHealth",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'RC status' updates.
        pub async fn subscribe_rc_status(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeRcStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RcStatusResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeRcStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeRcStatus",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'status text' updates.
        pub async fn subscribe_status_text(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeStatusTextRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StatusTextResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeStatusText",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeStatusText",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'actuator control target' updates.
        pub async fn subscribe_actuator_control_target(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SubscribeActuatorControlTargetRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::ActuatorControlTargetResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeActuatorControlTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeActuatorControlTarget",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'actuator output status' updates.
        pub async fn subscribe_actuator_output_status(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeActuatorOutputStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::ActuatorOutputStatusResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeActuatorOutputStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeActuatorOutputStatus",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'odometry' updates.
        pub async fn subscribe_odometry(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeOdometryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::OdometryResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeOdometry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeOdometry",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'position velocity' updates.
        pub async fn subscribe_position_velocity_ned(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribePositionVelocityNedRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PositionVelocityNedResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribePositionVelocityNed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribePositionVelocityNed",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'ground truth' updates.
        pub async fn subscribe_ground_truth(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeGroundTruthRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GroundTruthResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeGroundTruth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeGroundTruth",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'fixedwing metrics' updates.
        pub async fn subscribe_fixedwing_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeFixedwingMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::FixedwingMetricsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeFixedwingMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeFixedwingMetrics",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'IMU' updates (in SI units in NED body frame).
        pub async fn subscribe_imu(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeImuRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ImuResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeImu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeImu",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'Scaled IMU' updates.
        pub async fn subscribe_scaled_imu(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeScaledImuRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ScaledImuResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeScaledImu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeScaledImu",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'Raw IMU' updates.
        pub async fn subscribe_raw_imu(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeRawImuRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::RawImuResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeRawImu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeRawImu",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'HealthAllOk' updates.
        pub async fn subscribe_health_all_ok(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeHealthAllOkRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HealthAllOkResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeHealthAllOk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeHealthAllOk",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'unix epoch time' updates.
        pub async fn subscribe_unix_epoch_time(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeUnixEpochTimeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::UnixEpochTimeResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeUnixEpochTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeUnixEpochTime",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'Distance Sensor' updates.
        pub async fn subscribe_distance_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeDistanceSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DistanceSensorResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeDistanceSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeDistanceSensor",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'Scaled Pressure' updates.
        pub async fn subscribe_scaled_pressure(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeScaledPressureRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ScaledPressureResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeScaledPressure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeScaledPressure",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Subscribe to 'Heading' updates.
        pub async fn subscribe_heading(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeHeadingRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HeadingResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SubscribeHeading",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SubscribeHeading",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Set rate to 'position' updates.
        pub async fn set_rate_position(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRatePositionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRatePositionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRatePosition",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRatePosition",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'home position' updates.
        pub async fn set_rate_home(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateHomeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateHomeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateHome",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateHome",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to in-air updates.
        pub async fn set_rate_in_air(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateInAirRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateInAirResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateInAir",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateInAir",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to landed state updates
        pub async fn set_rate_landed_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateLandedStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateLandedStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateLandedState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateLandedState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to VTOL state updates
        pub async fn set_rate_vtol_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateVtolStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateVtolStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateVtolState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateVtolState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'attitude' updates.
        pub async fn set_rate_attitude(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateAttitudeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateAttitudeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateAttitude",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateAttitude",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate of camera attitude updates.
        pub async fn set_rate_camera_attitude(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateCameraAttitudeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateCameraAttitudeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateCameraAttitude",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateCameraAttitude",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'ground speed' updates (NED).
        pub async fn set_rate_velocity_ned(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateVelocityNedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateVelocityNedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateVelocityNed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateVelocityNed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'GPS info' updates.
        pub async fn set_rate_gps_info(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateGpsInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateGpsInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateGpsInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateGpsInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'battery' updates.
        pub async fn set_rate_battery(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateBatteryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateBatteryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateBattery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateBattery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'RC status' updates.
        pub async fn set_rate_rc_status(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateRcStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateRcStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateRcStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateRcStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'actuator control target' updates.
        pub async fn set_rate_actuator_control_target(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateActuatorControlTargetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateActuatorControlTargetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateActuatorControlTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateActuatorControlTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'actuator output status' updates.
        pub async fn set_rate_actuator_output_status(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateActuatorOutputStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateActuatorOutputStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateActuatorOutputStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateActuatorOutputStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'odometry' updates.
        pub async fn set_rate_odometry(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateOdometryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateOdometryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateOdometry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateOdometry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'position velocity' updates.
        pub async fn set_rate_position_velocity_ned(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRatePositionVelocityNedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRatePositionVelocityNedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRatePositionVelocityNed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRatePositionVelocityNed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'ground truth' updates.
        pub async fn set_rate_ground_truth(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateGroundTruthRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateGroundTruthResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateGroundTruth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateGroundTruth",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'fixedwing metrics' updates.
        pub async fn set_rate_fixedwing_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateFixedwingMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateFixedwingMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateFixedwingMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateFixedwingMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'IMU' updates.
        pub async fn set_rate_imu(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateImuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateImuResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateImu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateImu",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'Scaled IMU' updates.
        pub async fn set_rate_scaled_imu(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateScaledImuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateScaledImuResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateScaledImu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateScaledImu",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'Raw IMU' updates.
        pub async fn set_rate_raw_imu(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateRawImuRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateRawImuResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateRawImu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateRawImu",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'unix epoch time' updates.
        pub async fn set_rate_unix_epoch_time(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateUnixEpochTimeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateUnixEpochTimeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateUnixEpochTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateUnixEpochTime",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set rate to 'Distance Sensor' updates.
        pub async fn set_rate_distance_sensor(
            &mut self,
            request: impl tonic::IntoRequest<super::SetRateDistanceSensorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SetRateDistanceSensorResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/SetRateDistanceSensor",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "SetRateDistanceSensor",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the GPS location of where the estimator has been initialized.
        pub async fn get_gps_global_origin(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGpsGlobalOriginRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetGpsGlobalOriginResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/mavsdk.rpc.telemetry.TelemetryService/GetGpsGlobalOrigin",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "mavsdk.rpc.telemetry.TelemetryService",
                        "GetGpsGlobalOrigin",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
